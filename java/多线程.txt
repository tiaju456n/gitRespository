多线程作用是充分利用cpu，如果是单线程，得一个任务运行完后，再运行其他任务。这中间其实有很多时间cpu是闲置的。


 多线程基础：
 1：java实现多线程3种方式：
	1）继承Thread类（这个类实现了Runnable接口）
		具体:重写Thread的run（）方法。在主线程中使用这个类的实例.start()方法来起一个新的线程。
		public class Test extends Thread{
			public void run(){
				System.out.println("11");
			}
			public static void main(String[] args) {
				Test t1=new Test();
				t1.start();
				Test t2=new Test();
				t2.start();       //这种实现多线程的方法就不可以多个线程共享资源。t1不可以两次start，否则会报错
			}
		}
		
		
	2）自己实现Runnable接口
		 具体：实现run（）方法。  起线程：借用Thread的有参（这个参数就是这个类的实例）实例对象的start（）方法。实例一个Thread类，就起一个线程。
		 public class Test implements Runnable{

			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("1111");
			}
			
			public static void main(String[] args) {
				Test t=new Test();
				new Thread(t).start();
				new Thread(t).start();  //这两个线程是否共享资源，就在于new Thread（参数）这个参数对象是否是同一个对象。
			}
			
		}
	
			
			
继承Thread类和实现Runnale方法相比最大的不同就是线程之间对资源的共享与否。继承Thread的类的多线程无法对资源共享，想要起新的线程，就得实例这个类的新对象。实现Ruannable是可以对资源共享的（可控制），比Thread灵活。再者java只能继承一个类但可实现多个接口，所以一般都是用实现接口的方法。
			
	3）实现Callable接口
		具体：实现Callable的call（）方法。起线程：将这个实现类的实例放入FuterTask的实例中，再将FuterTask的实例放入Thread的实例中，最后用Thread的start（）方法起线程
		public class Test implements Callable<String>{

			@Override
			public String call() throws Exception {
				// TODO Auto-generated method stub
				System.out.println("ss");
				int i;
				for (i = 0; i < 10; i++) {
					i++;
				}
				return i+"";
			}
			
			public static void main(String[] args) throws InterruptedException, ExecutionException {
				Test t=new Test();
				FutureTask<String> ft=new FutureTask<String>(t);
				Thread th = new Thread(ft);
				th.start();
				System.out.println(ft.get()+ft.isDone());
				
			}

		}

也就是说这三种实现多线程的方法，起线程最终都是要用Thread实例的start（）方法起
Callable和Runable相比，多了返回值，并抛了异常。它的返回值从FutureTask的实例获得。同时通过FutureTask的实例还可以获得线程运行的一些情况。比如线程是否运行完成。







线程池：当任务数量确定时，可以用上面的方法手动创建确定的线程数去运行任务。但是当任务不定时，或者任务量特别多的时候就要使用线程池了。线程池的概念和数据库的连接池类似。起一个线程，关一个线程是很费时间和资源的，如果任务量多，频繁的去开启关闭线程就会导致运行时间过慢，线程池就是在初始化时就提供一定数量的线程。当一个任务过来，线程池就会为他分配一个已经创建好的线程执行，当任务执行完毕后，这个线程并不销毁，而是返回给线程池，线程池又会把这个线程分配给新的任务。


Java通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。



synchronized

强调一点：起多线程后，cpu是可以从线程的任意地方切换的，就是说执行完成一句后有可能去执行另一个线程了。而并不是一段代码。
因此，当一段代码可以被多个线程执行时，并且这些多线程有可能操作同一个对象时，就有可能出现与预期结果不符的情况，这就叫做线程不安全
这时候就需要synchronized。使用这个关键词后，被修饰的这段代码，只允许一个线程执行完，另一个线程才能执行。

还有一点要说的是：
全局变量存在堆中，所有拥有这个对象的线程对这个变量是共享的。
局部变量存在栈中，是每个线程独享的，其他线程是无法访问的。
因此，当一个对象的某个方法，有可能修改全局变量的值，且这个对象会被多个线程访问的时候，这个方法将有可能是线程不安全的。；‘









内存模型（物理层面，底层的内存模型，非java内存模型）：指令是由cpu执行的。一段代码执行时，会将这段代码从硬盘考入内存，然后cpu读取内存中的数据。但是，为了cpu更快的执行数据，cpu上其实还自带有高速的缓存。
代码执行时，会将内存中的数据复制到高速缓存中，执行完后再把结果刷回内存中。
这种方式在单核cpu时是没有任何问题的。但是如果是多核cpu呢？假如使用了四个线程去执行一个int i=4;i--;i--;i--;i--;的操作,而此时该电脑刚好有四个cpu，这四个线程每个
线程刚好分的一个cpu去执行这段代码。预期值应该是0，但是结果却不是0，而可能是3.为什么呢？多个cpu有可能刚好同时工作了，同时从内存中取到了i=4.然后都执行完后，刷回内存就变成i=3了。
为了解决多cpu，多线程，操作同一变量时出现的这个问题。有两个办法可以解决：
（1）在总线上加锁。cpu和其他部件都是通过总线进行通信的。总线上加了锁，那么其他cpu就访问不了内存了。只有等这个cpu执行完，将结果刷回内存释放了锁，其他cpu才能执行。
但是这样，显然牺牲了多cpu的效率。
（2）通过缓存一致性协议（比如intel的mesi协议）。主要意思是，一个cpu如果操作了共享变量，那么它就发一个信号给其他cpu，其他cpu得到信号后，就会从内存中重新去取值（此时内存中的值已经被那个cpu刷成了最新的）



并发中的三个概念：
1、原子性问题：
一个操作或者多个操作，要么全部执行，并且保证执行完。要么全不执行。（类似数据库中的事务）
java中自带原子操作的有：
（1）除long，double之外的基本类型的读取或者赋值操作（最新的jdk貌似已经解决了long、double的问题）
（2）java.util.concurrent.atomic 包下的所有类的所有操作
（3）所有引用reference的赋值操作？？？

2，可见性
多个线程访问同一个变量时，一个线程对变量做了修改，那么其他线程应该能够立刻感知

3.






线程的用户态/核心态。
用户态和核心态其实说的是线程的两种权限级别。可以简单的认为：
用户态就是这个线程的权限受限，很多事情做不了，比如访问硬盘，输入输出等，用户态的线程执行的代码是用户自己的（程序自己的），不需要去调用操作系统的功能。
核心态的线程没有权限限制，什么事都能干，线程想要切到核心态必须要去请求操作系统，调用操作系统的功能。java中常见的就是System类调用的方法。
用户态和核心态之间的切换是比较消耗资源的，代价是比较高的、


多线程的实现：
简单来说有三种实现方式：
1基于操作系统的多线程。即使用内核线程来实现。简单的认为线程创建，销毁等都是调用操作系统提供的接口实现的。
2使用用户线程实现。在操作系统之上，线程的所有控制由自己的代码完成。
3混合

java一般都是用第一种。


线程调度：线程调用就是系统为线程分配cpu使用权的过程。
调度方式有两种：
1协同式调度，一个线程拥有了cpu使用权后，会一直拥有，直到它自己用完了或者不想用了，会通知系统将使用权交回，再由系统分配给其他线程。
这种情况下也就不存在线程同步的问题，因为一个线程在运行时，其他线程是不可能从他手里抢到使用权的，那他就会一直执行下去。
但是这种情况有个很大的坏处，就是假如一个线程阻塞了，那它就会一直占用着cpu的资源，导致其他线程无法运行，最终就会导致系统崩溃。


2抢占式调度：每时每刻的cpu使用权都是由系统分配的。线程是没有占用cpu权限的。相当于线程在强cpu资源一样。这种方式的好处就在于不会造成系统崩溃。java的线程控制显然就是用的这种方式。但是坏处就是线程有可能会来回切换，造成线程不同步的问题。



线程的6种状态：
一个线程在任何一个时间点，都有且只能有一种状态，分别如下：

1.新建  new Thread（）
2.运行  start()
3.无限期等待wait（）
4.有限期等待sleep（）
5.阻塞synchronized  只有正在运行的线程让出使用权  被阻塞的线程才有被调用权
6，销毁 线程执行完成



volatile 称为轻量锁
主要有两方面作用：
（1）可见性
典型场景：一个线程通过一个变量去控制另一个线程停止，此时是需要为这个变量附上volatile关键词，用以确保一个线程改变了这个变量的值后另一个线程能够看到。
如果不加，有可能出现这种场景，一个线程虽然改变了变量的值，但是由于另一个线程一直使用的是自己工作内存的变量值，并未从主内存取值，导致整个线程无法停下来。

（2）有序性
具体可以认为有两种特性：

1.典型场景：在做单实例时，使用双重判空的形式，其中的单实例变量需要使用volatile修饰。原因是，在生成实例时，其实是有三步的：为这个实例分配内存空间，创建实例对象，使变量指向这个内存地址。其中23步的顺序是不定的，在单线程的时候其实没有问题。但是如果是多线程，有可能出现一个线程创建出来对象时，使变量指向了这个内存，但还么有创建出对象，另一个线程过来以为对象已经建好了，就拿去用了，此时就会导致jvm虚拟机出错。（写操作先行发生于读操作）

2.它会阻止他前面和后面的指令交换顺序，即它前面的不能到后面，后面的不能到前面。比较直观的就是对于一串代码，访问被volatile修饰的变量的那句指令，会阻止它前后的代码交换顺序。
比如：	（1）x=10;
		（2）y=1;
		（3）flag = true；
		（4）z=1;
其中flag被volatile修饰，那么（3）肯定就会在（1）（2）后执行，在（4）前。但是（1）（2）是可以被重排序的。


先行性原则：
先行发生。即针对两个操作a,b。如果说a先行发生于b，那么就是说a操作的结果，b是能够感知到的。
java先天就针对一些操作做了先行发生的规定。

1.程序次序规则：一个线程内，写在前面的操作先行发生于发生在后面的操作。注意理解这里的意思：从java源码到运行，java的指令要经过好几次重排序，编译的时候，运行的时候都有可能重排序。但是无论怎么排序，针对一个线程的时候，都会保证逻辑上前面的操作在肯定在前面。
比如 int i=1；j=i;java在一个线程内肯定是会保证i=1，在j=i；前面的，所以在一个线程内就不需要操心给j赋值时，i还没有赋值。


2.对一个volatile写操作先行发生于读操作之前。
指的是如果一个线程先去对volatile修饰的变量进行了写操作，另一个线程执行读操作，那么写操作必定是先于读操作完成的。（这里就是上面单实例用到的特性）



volatile的底层原理：java被编成底层语言（汇编语言），被修饰的变量前会多一个lock前缀。这个lock就是内存屏障。










































































	
	
	
	
	
	
	
	
	
	